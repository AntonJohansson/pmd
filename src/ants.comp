#version 430

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

layout(rgba32f, binding = 3) uniform image2D scent;
layout(rgba32f, binding = 4) uniform image2D walls;

layout(std430, binding = 1) buffer ants_pos {
    vec2 pos[];
};

layout(std430, binding = 2) buffer ants_vel {
    vec2 vel[];
};

uniform float dt;
uniform float sense_angle;
uniform float turn_left_interval;
uniform float turn_right_interval;
uniform float move_randomly_interval;
uniform float vel_value;

#define PI 3.1415926538

uvec2 size = imageSize(scent);

uint random_next_u32_xors(uint state) {
    state ^= 2747636419u;
    state *= 2654435769u;
    state ^= state >> 13;
    state *= 2654435769u;
    state ^= state >> 17;
    state *= 2654435769u;
    return state;
}

float random_unilateral_xors(uint state) {
    float divisor = 1.0f / float(uint(-1));
    float result = divisor * float(random_next_u32_xors(state));
    return result;
}

float random_bilateral_xors(uint state) {
    return 2.0f*random_unilateral_xors(state) - 1.0f;
}

vec4 sample_sensor(vec2 pos, float angle) {
    float dist = 10;
    float len = 4;

    ivec2 center = ivec2(dist*cos(angle) + pos.x,
                         dist*sin(angle) + pos.y);

    vec4 sum = vec4(0,0,0,0);
    for (int y = 0; y < len; ++y) {
        for (int x = 0; x < len; ++x) {
            ivec2 p = ivec2(center.x + (-len/2 + x),
                            center.y + (-len/2 + y));
            sum += imageLoad(scent, p);
        }
    }

    return sum;
}

uint hash(vec2 p) {
    uint i = gl_GlobalInvocationID.x;
    return (i << 3) + uint(p.x) + size.y * uint(p.y);
}

void main() {
    uint i = gl_GlobalInvocationID.x;

    float base_angle = atan(vel[i].y, vel[i].x);

    vec4 l = sample_sensor(pos[i], base_angle + sense_angle);
    vec4 c = sample_sensor(pos[i], base_angle);
    vec4 r = sample_sensor(pos[i], base_angle - sense_angle);

    if (l.b > 0 || c.b > 0 || r.b > 0) {
        vel[i].x = -vel[i].x;
        vel[i].y = -vel[i].y;
    } else {
        if (c.r > l.r && c.r > r.r) {
        } else if (c.r < l.r && c.r < r.r) {
            float delta = move_randomly_interval*(random_bilateral_xors(hash(pos[i]))/2.0);
            vel[i] = length(vel[i])*vec2(cos(base_angle + delta), sin(base_angle + delta));
        } else if (l.r > r.r) {
            float delta = turn_left_interval*(random_unilateral_xors(hash(pos[i]))/2.0);
            vel[i] = length(vel[i])*vec2(cos(base_angle + delta), sin(base_angle + delta));
        } else if (r.r > l.r) {
            float delta = turn_right_interval*(random_unilateral_xors(hash(pos[i]))/2.0);
            vel[i] = length(vel[i])*vec2(cos(base_angle - delta), sin(base_angle - delta));
        }
    }

    vec2 new_pos = pos[i] + dt*vel_value*normalize(vel[i]);
    // Collide walls
    if (imageLoad(walls, ivec2(new_pos)).r > 0) {
        float angle = base_angle + PI + random_bilateral_xors(hash(pos[i])) * PI/2.0;
        vel[i] = length(vel[i])*vec2(cos(angle), sin(angle));
    } else {
        pos[i] = new_pos;
    }

    // Collide sides
    if (pos[i].x < 0) {
        pos[i].x = 0;
        float angle = -PI/2.0 + random_unilateral_xors(hash(pos[i])) * PI;
        vel[i] = length(vel[i])*vec2(cos(angle), sin(angle));
    } else if (pos[i].x > size.x) {
        pos[i].x = size.x;
        float angle = PI/2.0 + random_unilateral_xors(hash(pos[i])) * PI;
        vel[i] = length(vel[i])*vec2(cos(angle), sin(angle));
    }

    // Collide top bottom
    if (pos[i].y < 0) {
        pos[i].y = 0;
        float angle = random_unilateral_xors(hash(pos[i])) * PI;
        vel[i] = length(vel[i])*vec2(cos(angle), sin(angle));
    } else if (pos[i].y > size.y) {
        pos[i].y = size.y;
        float angle = PI + random_unilateral_xors(hash(pos[i])) * PI;
        vel[i] = length(vel[i])*vec2(cos(angle), sin(angle));
    }

    imageStore(scent, ivec2(pos[i]), vec4(1,0,0,1));
}
